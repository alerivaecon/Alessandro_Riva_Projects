import numpy as np

def solve_backwards(beta,W,T):
    # 2. Initialize
    Vstar_bi = np.nan+np.zeros([W+1,T])
    Cstar_bi = np.nan + np.zeros([W+1,T])
    Cstar_bi[:,T-1] = np.arange(W+1) 
    Vstar_bi[:,T-1] = np.sqrt(Cstar_bi[:,T-1])
    # 3. solve
    
    # Loop over periods
    for t in reversed(range(0,T-1,1)):  # backwards  
    
    #loop over states
        for w in range(W+1):
            c = np.arange(w+1)
            w_t_1 = w - c
            V_next = Vstar_bi[w_t_1,t+1]
            guess_V = np.sqrt(c)+beta*V_next
            Vstar_bi[w,t] = np.amax(guess_V)
            Cstar_bi[w,t] = np.argmax(guess_V)

    return Cstar_bi, Vstar_bi

beta = 0.9
W = 5
T = 3
C,V = solve_backwards(beta=beta, W=W, T=T)
print(C)
# 4. simulate
C_back = np.empty(T)
W_nw = W
for t in range(T):
    W_nw = int(W_nw)  
    C_back[t] = C[W_nw,t]  
    W_nw = W_nw-C_back[t]
display(C_back)
display(W_nw)

